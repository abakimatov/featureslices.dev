# v1.0 [![](https://img.shields.io/badge/feature/slices-1.0-blue)](https://featureslices.dev/v1.0)

```md
[![](https://img.shields.io/badge/feature/slices-1.0-blue)](https://featureslices.dev/v1.0)
```

## Usage

In that examples TypeScript used as common language, but you free to choose.

### Applications

- [Authmenow](https://github.com/authmenow/frontend) `Work in progress`

### Examples

- [Effector React SSR](https://github.com/sergeysova/effector-ssr-typescript-react-styled)
- [CreateReactApp Effector template](https://github.com/sergeysova/cra-template-effector)

## Introduction

FeatureSlices define your frontend application structure as easy and convenient.

### Convention

- All files and directories has name in param-case. Because it lowers cognitive load to select case for concrete file. One case for all files. File structure should define what type file have. Example: `component-name.tsx`

### Structure

Source code of the application contained in `src`:

- `api`
- `features`
- `lib`
- `pages`
- `ui`

#### Api

This is reusable functions or classes to make requests to the server. It is can be REST-like, GraphQL, WebSocket, etc.

Code in the `api` can be partially generated (swagger or OpenAPI).

What is API:

```
src/
  api/
    namespace.ts
    request.ts
```

For example `namespace` is a group of requests, having a common purpose. More that one namespace can be created.

Not recommended to add `src/api/index.ts` file, because different api should be separated one from one. If you import `api/user`, you see just requests related to user. But if you import `api`, you can be drowned in tons of requests for application.

Example:

```
src/
  api/
    post.ts
    feed.ts
    session.ts
    request.ts
```

In this example: `post`, `feed`, `session` is a namespaced requests, but `request` is a base function, to make requests.

Example `post.ts`:

```ts
import { request } from './request'

interface PostNew {
  title: string;
  content: string;
}

export const postsList = () => request({ method: "GET", path: "/posts" })

export const postCreate = (post: PostNew) => request({ method: "POST", path: "/posts", body: post })

export const postGet = (postId: string) => request({ method: "GET", path: `/posts/${postId}` })
```

Structure and shape of each method on your own. But it should be consistent with all other requests.

> Recommended to setup imports in your project, to allow import from root (`src/`) or use some aliases.

From `api` source code you can import only `src/lib` and package dependencies, nothing more.

**Good:**

```ts
import { postsList } from 'api/post'
// or
import * posts from '@api/post'
```

**Bad:**

```ts
import { posts } from '../../../api'
```

#### Features

It is list of your reusable code and shared state, groupped by one idea or entity.

Structure:

```
src/
  features/
    feature-name/
      components/
      models/
      templates/
      __tests__/
      index.ts
      readme.md
      stories.tsx
```

- One feature can depends on another feature. But not recommended to do it too often.
- Do not make cyclic dependencies, when feature A depends on feature B, feature B on C, and C depends on A. Prefer tree over graph.
- Export all entities from your feature through `index.ts`. It is helps to support your feature easier, because through that public interface, you can known what is used, and what can be refactored without stress.
- Write tests and documentation for feature, to ease understanding how to use it.
- You can have as many features as you need, but no more.

Feature structure:

- `components/` here should be atoms, molecules and organisms of your features. All should be related to single idea or entity.
- `models/` here place business-logic, that can be reused (instantiated) or shared between other features and pages. Any shared state also here.
- `templates/` it is a place for atomic design templates for pages. Templates also should be relate to one idea or entity.
- `__tests__/` or `tests/` — any name of the directory to write integration or smoke tests.
- `index.ts` — public interface of your feature, all entities and units should be imported through this file. Import from inside is restricted.
  - Bad: `import {Some} from 'features/example/components/some`
  - Good: `import {Some} from 'features/example'`
- `readme.md` — documentation of your feature
- `stories.tsx` — if you use storybook


